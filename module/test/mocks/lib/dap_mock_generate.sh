#!/bin/bash
# Generate output files (wrap, cmake, macros, templates)

# Source common utilities (but don't initialize yet - that's done in main script)
LIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${LIB_DIR}/dap_mock_common.sh"

# Generate linker response file with --wrap options
generate_wrap_file() {
    local wrap_file="$1"
    local mock_functions="$2"
    
    > "$wrap_file"  # Clear file
    if [ -n "$mock_functions" ]; then
        local func_count=$(echo "$mock_functions" | wc -l)
        echo "$mock_functions" | while read func; do
            # Note: For -Wl,@file usage, we need just --wrap=func (without -Wl,)
            echo "--wrap=$func" >> "$wrap_file"
        done
        print_success "Generated $func_count --wrap options"
    else
        # Create truly empty file - linker response files cannot contain comments
        > "$wrap_file"
        print_info "Created empty wrap file (no mocks to wrap)"
    fi
}

# Generate CMake integration file
generate_cmake_file() {
    local cmake_file="$1"
    local mock_functions="$2"
    
    cat > "$cmake_file" << EOF
# Auto-generated mock configuration
# Generated by dap_mock_autowrap.sh

# Wrapped functions:
EOF

    if [ -n "$mock_functions" ]; then
        echo "$mock_functions" | while read func; do
            echo "#   - $func" >> "$cmake_file"
        done
    else
        echo "#   (none - no mocks declared)" >> "$cmake_file"
    fi
    
    print_success "Generated CMake integration"
}

# Generate macros header file
# Usage: generate_macros_file <macros_file> [custom_mocks_file]
generate_macros_file() {
    local macros_file="$1"
    local custom_mocks_file="${2:-${TMP_CUSTOM_MOCKS}}"
    local return_type_macros_file="${macros_file}.return_types"
    local simple_wrapper_macros_file="${macros_file}.simple_wrappers"
    local function_wrappers_file="${macros_file}.function_wrappers"
    
    # Generate return type macros using types module
    source "${LIB_DIR}/dap_mock_types.sh"
    generate_return_type_macros "$return_type_macros_file"
    
    # Generate function-specific wrapper macros (if custom_mocks_file is available)
    if [ -n "$custom_mocks_file" ] && [ -f "$custom_mocks_file" ]; then
        generate_function_wrappers "$function_wrappers_file" "$custom_mocks_file"
    else
        > "$function_wrappers_file"
    fi
    
    # Generate simple wrapper macros (if needed)
    > "$simple_wrapper_macros_file"
    
    # Prepare template data
    prepare_nargs_data "$MAX_ARGS_COUNT"
    prepare_map_count_params_by_count_data "$MAX_ARGS_COUNT"
    prepare_map_count_params_helper_data "$MAX_ARGS_COUNT"
    prepare_map_impl_cond_1_data "$MAX_ARGS_COUNT" "${PARAM_COUNTS_ARRAY[@]}"
    prepare_map_impl_cond_data "${PARAM_COUNTS_ARRAY[@]}"
    prepare_map_macros_data "${PARAM_COUNTS_ARRAY[@]}"
    
    # Generate mock_map_macros content with template language constructs
    RETURN_TYPE_MACROS_FILE="$return_type_macros_file" \
    SIMPLE_WRAPPER_MACROS_FILE="$simple_wrapper_macros_file" \
    # Convert PARAM_COUNTS_ARRAY to pipe-separated string for dap_tpl for loop
    # dap_tpl for_evaluator expects pipe-separated or newline-separated arrays
    PARAM_COUNTS_ARRAY_PIPE=$(IFS='|'; echo "${PARAM_COUNTS_ARRAY[*]}")
    
    PARAM_COUNTS_ARRAY="${PARAM_COUNTS_ARRAY[*]}" \
    MAX_ARGS_COUNT="$MAX_ARGS_COUNT" \
    MAP_COUNT_PARAMS_BY_COUNT_DATA="$MAP_COUNT_PARAMS_BY_COUNT_DATA" \
    MAP_COUNT_PARAMS_HELPER_DATA="$MAP_COUNT_PARAMS_HELPER_DATA" \
    MAP_IMPL_COND_1_DATA="$MAP_IMPL_COND_1_DATA" \
    MAP_IMPL_COND_DATA="$MAP_IMPL_COND_DATA" \
    replace_template_placeholders_with_mocking \
        "${TEMPLATES_DIR}/mock_map_macros.h.tpl" \
        "${macros_file}.map_content" \
        "RETURN_TYPE_MACROS_FILE=$return_type_macros_file" \
        "SIMPLE_WRAPPER_MACROS_FILE=$simple_wrapper_macros_file" \
        "PARAM_COUNTS_ARRAY=$PARAM_COUNTS_ARRAY_PIPE" \
        "MAX_ARGS_COUNT=$MAX_ARGS_COUNT" \
        "MAP_COUNT_PARAMS_BY_COUNT_DATA=$MAP_COUNT_PARAMS_BY_COUNT_DATA" \
        "MAP_COUNT_PARAMS_HELPER_DATA=$MAP_COUNT_PARAMS_HELPER_DATA" \
        "MAP_IMPL_COND_1_DATA=$MAP_IMPL_COND_1_DATA" \
        "MAP_IMPL_COND_DATA=$MAP_IMPL_COND_DATA"
    
    # Export file paths for template processing
    export RETURN_TYPE_MACROS_FILE="$return_type_macros_file"
    export SIMPLE_WRAPPER_MACROS_FILE="$simple_wrapper_macros_file"
    export FUNCTION_WRAPPERS_FILE="$function_wrappers_file"
    export MAP_MACROS_CONTENT_FILE="${macros_file}.map_content"
    
    # Verify files exist before template processing
    if [ ! -f "$RETURN_TYPE_MACROS_FILE" ]; then
        print_error "RETURN_TYPE_MACROS_FILE does not exist: $RETURN_TYPE_MACROS_FILE"
        return 1
    fi
    
    # Save file paths before they might be overwritten in function calls
    local saved_return_type_macros_file="$RETURN_TYPE_MACROS_FILE"
    local saved_simple_wrapper_macros_file="$SIMPLE_WRAPPER_MACROS_FILE"
    
    if [ -n "$saved_return_type_macros_file" ] && [ -f "$saved_return_type_macros_file" ] && [ -s "$saved_return_type_macros_file" ]; then
        # First generate template without return type macros
        # Convert PARAM_COUNTS_ARRAY to pipe-separated string for dap_tpl for loop
        PARAM_COUNTS_ARRAY_PIPE=$(IFS='|'; echo "${PARAM_COUNTS_ARRAY[*]}")
        
        replace_template_placeholders_with_mocking \
            "${TEMPLATES_DIR}/mock_macros_header.h.tpl" \
            "$macros_file" \
            "MAX_ARGS_COUNT=$MAX_ARGS_COUNT" \
            "PARAM_COUNTS_ARRAY=$PARAM_COUNTS_ARRAY_PIPE" \
            "NARGS_SEQUENCE=$NARGS_SEQUENCE" \
            "NARGS_IMPL_PARAMS=$NARGS_IMPL_PARAMS" \
            "MAP_MACROS_DATA=$MAP_MACROS_DATA" \
            "MAP_MACROS_CONTENT_FILE=${MAP_MACROS_CONTENT_FILE}" \
            "RETURN_TYPE_MACROS_FILE=" \
            "SIMPLE_WRAPPER_MACROS_FILE=$saved_simple_wrapper_macros_file" \
            "FUNCTION_WRAPPERS_FILE=$function_wrappers_file"
        
        # Append return type macros directly
        cat "$saved_return_type_macros_file" >> "$macros_file"
        
        # Append simple wrapper macros if they exist
        if [ -n "$saved_simple_wrapper_macros_file" ] && [ -f "$saved_simple_wrapper_macros_file" ] && [ -s "$saved_simple_wrapper_macros_file" ]; then
            cat "$saved_simple_wrapper_macros_file" >> "$macros_file"
        fi
    else
        # No return types - use normal template processing
        # Convert PARAM_COUNTS_ARRAY to pipe-separated string for dap_tpl for loop
        PARAM_COUNTS_ARRAY_PIPE=$(IFS='|'; echo "${PARAM_COUNTS_ARRAY[*]}")
        
        replace_template_placeholders_with_mocking \
            "${TEMPLATES_DIR}/mock_macros_header.h.tpl" \
            "$macros_file" \
            "MAX_ARGS_COUNT=$MAX_ARGS_COUNT" \
            "PARAM_COUNTS_ARRAY=$PARAM_COUNTS_ARRAY_PIPE" \
            "NARGS_SEQUENCE=$NARGS_SEQUENCE" \
            "NARGS_IMPL_PARAMS=$NARGS_IMPL_PARAMS" \
            "MAP_MACROS_DATA=$MAP_MACROS_DATA" \
            "MAP_MACROS_CONTENT_FILE=${MAP_MACROS_CONTENT_FILE}" \
            "RETURN_TYPE_MACROS_FILE=$return_type_macros_file" \
            "SIMPLE_WRAPPER_MACROS_FILE=$simple_wrapper_macros_file" \
            "FUNCTION_WRAPPERS_FILE=$function_wrappers_file"
    fi
    
    # Clean up temporary files AFTER template processing is complete
    # Note: map_content file is included via {{#include}}, so it must exist during template processing
    # It will be cleaned up after the final template is generated
    rm -f "$return_type_macros_file" "$simple_wrapper_macros_file"
    # Keep map_content file for now - it's needed for include processing
    # It will be cleaned up later if needed
    
    print_success "Generated macros header with ${#PARAM_COUNTS_ARRAY[@]} parameter count(s)"
    if [ -n "$RETURN_TYPES" ]; then
        local return_types_count=$(echo "$RETURN_TYPES" | wc -w)
        print_success "Generated specialized macros for $return_types_count return type(s): $RETURN_TYPES"
    fi
}

# Generate dap_mock_linker_wrapper.h from template
generate_linker_wrapper_header() {
    local linker_wrapper_file="$1"
    
    # Prepare ORIGINAL_TYPES_DATA as string for template (normalized|original pairs)
    local ORIGINAL_TYPES_DATA=""
    if [ -n "$RETURN_TYPES_PAIRS" ]; then
        ORIGINAL_TYPES_DATA="$RETURN_TYPES_PAIRS"
        # Debug: verify ORIGINAL_TYPES_DATA contains expected types
        [ "$VERBOSE" = "1" ] && echo "DEBUG generate_linker_wrapper_header: RETURN_TYPES_PAIRS=[$RETURN_TYPES_PAIRS]" >&2
        [ "$VERBOSE" = "1" ] && echo "DEBUG generate_linker_wrapper_header: ORIGINAL_TYPES_DATA=[$ORIGINAL_TYPES_DATA]" >&2
    fi
    
    # Generate linker wrapper header from template
    # The template contains only base macros - dispatcher macros are generated separately
    replace_template_placeholders_with_mocking \
        "${TEMPLATES_DIR}/dap_mock_linker_wrapper.h.tpl" \
        "$linker_wrapper_file"
    
    print_success "Generated linker wrapper header"
}

# Generate wrapper template file
generate_template_file() {
    local template_file="$1"
    local mock_functions="$2"
    local wrapper_functions="$3"
    
    if [ -z "$mock_functions" ]; then
        print_info "No mocks declared - skipping template generation"
        return 0
    elif [ -n "$wrapper_functions" ]; then
        local missing_functions=$(comm -23 <(echo "$mock_functions" | sort) <(echo "$wrapper_functions" | sort))
        
        if [ -z "$missing_functions" ]; then
            print_success "All wrappers are defined"
            return 0
        else
            local missing_count=$(echo "$missing_functions" | wc -l)
            print_warning "Missing wrappers for $missing_count functions"
            print_info "Generating template: $template_file"
            
            # Generate template file using main template
            MISSING_FUNCTIONS="$missing_functions" \
            replace_template_placeholders_with_mocking \
                "${TEMPLATES_DIR}/wrapper_template.h.tpl" \
                "$template_file"
            
            # Show missing functions
            echo "$missing_functions" | while read func; do
                [ -z "$func" ] && continue
                echo "   ⚠️  $func"
            done
            
            print_success "Template generated with $missing_count function stubs"
        fi
    else
        # No wrappers found but mocks exist - generate template for all
        local func_count=$(echo "$mock_functions" | wc -l)
        print_warning "No wrappers found for $func_count functions"
        print_info "Generating template: $template_file"
        
        # Generate template file using main template
        MISSING_FUNCTIONS="$mock_functions" \
        replace_template_placeholders_with_mocking \
            "${TEMPLATES_DIR}/wrapper_template.h.tpl" \
            "$template_file"
        
        # Show missing functions
        echo "$mock_functions" | while read func; do
            [ -z "$func" ] && continue
            echo "   ⚠️  $func"
        done
        
        print_success "Template generated with $func_count function stubs"
    fi
}

# Generate custom mock headers for each custom mock declaration
# Usage: generate_custom_mock_headers <output_dir> <basename> <custom_mocks_file> <wrapper_functions>
generate_custom_mock_headers() {
    local output_dir="$1"
    local basename="$2"
    local custom_mocks_file="$3"
    local wrapper_functions="$4"
    local temp_files=()  # Track temporary files for cleanup
    
    if [ ! -f "$custom_mocks_file" ] || [ ! -s "$custom_mocks_file" ]; then
        print_info "No custom mocks found - creating custom mocks header with macros only"
        local main_custom_mocks_file="${output_dir}/${basename}_custom_mocks.h"
        
        # Generate empty main include file using template
        replace_template_placeholders_with_mocking \
            "${TEMPLATES_DIR}/custom_mocks_main_empty.h.tpl" \
            "$main_custom_mocks_file" \
            "BASENAME=$basename"
        return 0
    fi
    
    local custom_mocks_count=$(wc -l < "$custom_mocks_file" | tr -d ' ')
    
    # Create directory for custom mock headers
    local custom_mocks_dir="${output_dir}/custom_mocks"
    mkdir -p "$custom_mocks_dir"
    
    # Process each custom mock declaration
    while IFS='|' read -r return_type func_name param_list macro_type; do
        [ -z "$func_name" ] && continue
        
        # Skip if function already has a wrapper defined in source files
        if echo "$wrapper_functions" | grep -q "^${func_name}$"; then
            continue
        fi
        
        # Create header file name based on function name
        local header_file="${custom_mocks_dir}/${func_name}_mock.h"
        
        # Parse parameters from param_list
        local param_decl=""
        local param_names=""
        local param_array=""
        local param_count=0
        
        if [ "$param_list" = "void" ] || [ -z "$param_list" ]; then
            param_decl="void"
            param_names=""
            param_array="NULL"
            param_count=0
        else
            # Extract PARAM(type, name) entries
            local clean_params=$(echo "$param_list" | tr -d ' \t\n')
            param_count=$(echo "$clean_params" | grep -o "PARAM(" | wc -l)
            
            if [ "$param_count" -eq 0 ]; then
                param_decl="void"
                param_names=""
                param_array="NULL"
                param_count=0
            else
                # Extract each PARAM(type, name)
                local param_decl_parts=()
                local param_name_parts=()
                local param_array_parts=()
                
                # Use awk script to extract PARAM entries
                local tmp_params_file=$(create_temp_file "params_${func_name}")
                temp_files+=("$tmp_params_file")
                echo "$param_list" | gawk -f "${MOCK_AWK_DIR}/parse_params.awk" > "$tmp_params_file"
                
                # Read extracted parameters
                while IFS='|' read -r param_type param_name; do
                    [ -z "$param_type" ] && continue
                    param_decl_parts+=("$param_type $param_name")
                    param_name_parts+=("$param_name")
                    param_array_parts+=("(void*)(intptr_t)$param_name")
                done < "$tmp_params_file"
                
                # Join parameters with proper formatting
                if [ ${#param_decl_parts[@]} -gt 0 ]; then
                    param_decl=$(IFS=','; printf '%s, ' "${param_decl_parts[@]}" | sed 's/, $//')
                    param_names=$(IFS=','; printf '%s, ' "${param_name_parts[@]}" | sed 's/, $//')
                    param_array="((void*[]){$(IFS=','; printf '%s, ' "${param_array_parts[@]}" | sed 's/, $//')})"
                    param_count=${#param_decl_parts[@]}
                else
                    param_decl="void"
                    param_names=""
                    param_array="NULL"
                    param_count=0
                fi
            fi
        fi
        
        # Prepare template variables
        local guard_name="${func_name^^}_MOCK_H"
        local wrapper_signature=""
        local result_declaration=""
        local mock_impl_call=""
        local real_function_call=""
        local return_value_override=""
        local record_call=""
        local return_statement=""
        local return_value_override_file=""
        local record_call_file=""
        
        if [ "$return_type" = "void" ]; then
            wrapper_signature="void __wrap_${func_name}($param_decl)"
            result_declaration=""
            if [ "$param_count" -eq 0 ]; then
                mock_impl_call="        __mock_impl_${func_name}();"
                real_function_call="        __real_${func_name}();"
            else
                mock_impl_call="        __mock_impl_${func_name}($param_names);"
                real_function_call="        __real_${func_name}($param_names);"
            fi
            return_value_override=""
            record_call=""
            return_statement=""
        else
            wrapper_signature="$return_type __wrap_${func_name}($param_decl)"
            result_declaration="    $return_type __wrap_result = ($return_type){0};"
            if [ "$param_count" -eq 0 ]; then
                mock_impl_call="        __wrap_result = __mock_impl_${func_name}();"
                real_function_call="        __wrap_result = __real_${func_name}();"
            else
                mock_impl_call="        __wrap_result = __mock_impl_${func_name}($param_names);"
                real_function_call="        __wrap_result = __real_${func_name}($param_names);"
            fi
            # Create temporary files for multi-line values
            return_value_override_file=$(create_temp_file "return_value_override_${func_name}")
            record_call_file=$(create_temp_file "record_call_${func_name}")
            temp_files+=("$return_value_override_file" "$record_call_file")
            {
                echo "        if (__wrap_mock_state && __wrap_mock_state->return_value.ptr) {"
                echo "            __wrap_result = *($return_type*)__wrap_mock_state->return_value.ptr;"
                echo "        }"
            } > "$return_value_override_file"
            echo "        dap_mock_record_call(__wrap_mock_state, __wrap_args, __wrap_args_count, (void*)(intptr_t)__wrap_result);" > "$record_call_file"
            return_value_override="@$return_value_override_file"
            record_call="@$record_call_file"
            return_statement="    return __wrap_result;"
        fi
        
        # Generate header file using template
        replace_template_placeholders_with_mocking \
            "${TEMPLATES_DIR}/custom_mock_header.h.tpl" \
            "$header_file" \
            "FUNC_NAME=$func_name" \
            "RETURN_TYPE=$return_type" \
            "PARAM_DECL=$param_decl" \
            "PARAM_NAMES=$param_names" \
            "PARAM_ARRAY=$param_array" \
            "PARAM_COUNT=$param_count" \
            "GUARD_NAME=$guard_name" \
            "WRAPPER_FUNCTION_SIGNATURE=$wrapper_signature" \
            "RESULT_DECLARATION=$result_declaration" \
            "MOCK_IMPL_CALL=$mock_impl_call" \
            "RETURN_VALUE_OVERRIDE=$return_value_override" \
            "RECORD_CALL=$record_call" \
            "REAL_FUNCTION_CALL=$real_function_call" \
            "RETURN_STATEMENT=$return_statement"
        
        print_success "Generated mock header: $header_file"
    done < "$custom_mocks_file"
    
    # Clean up temporary files
    cleanup_temp_files "${temp_files[@]}"
    
    # Create main include file that includes all custom mock headers
    local main_custom_mocks_file="${output_dir}/${basename}_custom_mocks.h"
    
    # Generate main include file using template
    # Check if custom_mocks_file has any non-empty lines
    local non_empty_lines=$(grep -v '^[[:space:]]*$' "$custom_mocks_file" | wc -l)
    if [ "$non_empty_lines" -eq 0 ]; then
        # File is empty or contains only whitespace - use empty template
        replace_template_placeholders_with_mocking \
            "${TEMPLATES_DIR}/custom_mocks_main_empty.h.tpl" \
            "$main_custom_mocks_file" \
            "BASENAME=$basename"
    else
        export CUSTOM_MOCKS_LIST="$(cat "$custom_mocks_file")"
        export WRAPPER_FUNCTIONS="$wrapper_functions"
        replace_template_placeholders_with_mocking \
            "${TEMPLATES_DIR}/custom_mocks_main.h.tpl" \
            "$main_custom_mocks_file" \
            "BASENAME=$basename"
    fi
    
    print_success "Generated main custom mocks include: $main_custom_mocks_file"
}

# Prepare MAP_IMPL_COND_1_DATA for template generation
# Format: arg_count|param_count|has_count|fallback_count|macro_params
# macro_params should NOT include "macro" - it's already in the macro parameter list
prepare_map_impl_cond_1_data() {
    local max_args_count="$1"
    shift
    local param_counts_array=("$@")
    
    [ -z "$max_args_count" ] && max_args_count=0
    [ "$max_args_count" -lt 0 ] && max_args_count=0
    
    declare -A HAS_PARAM_COUNT
    for count in "${param_counts_array[@]}"; do
        [ -z "$count" ] && continue
        HAS_PARAM_COUNT["$count"]=1
    done
    
    MAP_IMPL_COND_1_DATA=""
    for arg_count in $(seq 1 "$max_args_count"); do
        param_count=$((arg_count / 2))
        
        # Build macro_params starting with p1 (NOT macro - macro is already in parameter list)
        macro_params="p1"
        for j in $(seq 2 "$arg_count"); do
            macro_params="${macro_params}, p${j}"
        done
        
        has_count=0
        if [ "${HAS_PARAM_COUNT[$param_count]:-0}" = "1" ] || [ "$param_count" -eq 0 ]; then
            has_count=1
            fallback_count="$param_count"
        else
            fallback_count=0
            for count in "${param_counts_array[@]}"; do
                [ -z "$count" ] && continue
                if [ "$count" -le "$param_count" ] && [ "$count" -gt "$fallback_count" ]; then
                    fallback_count="$count"
                fi
            done
        fi
        
        if [ -n "$MAP_IMPL_COND_1_DATA" ]; then
            MAP_IMPL_COND_1_DATA="${MAP_IMPL_COND_1_DATA}"$'\n'"${arg_count}|${param_count}|${has_count}|${fallback_count}|${macro_params}"
        else
            MAP_IMPL_COND_1_DATA="${arg_count}|${param_count}|${has_count}|${fallback_count}|${macro_params}"
        fi
    done
}

# Prepare MAP_IMPL_COND_DATA for template generation
prepare_map_impl_cond_data() {
    local param_counts_array=("$@")
    MAP_IMPL_COND_DATA=""
    for count in "${param_counts_array[@]}"; do
        [ -z "$count" ] && continue
        if [ -n "$MAP_IMPL_COND_DATA" ]; then
            MAP_IMPL_COND_DATA="${MAP_IMPL_COND_DATA}"$'\n'"${count}"
        else
            MAP_IMPL_COND_DATA="${count}"
        fi
    done
}

# Prepare MAP_MACROS_DATA for template generation
prepare_map_macros_data() {
    local param_counts_array=("$@")
    local counts_input=""
    for count in "${param_counts_array[@]}"; do
        [ -z "$count" ] && continue
        if [ -n "$counts_input" ]; then
            counts_input="${counts_input}"$'\n'"${count}"
        else
            counts_input="${count}"
        fi
    done
    
    # Generate macros using AWK script
    local macros_content
    macros_content=$(echo "$counts_input" | gawk -f "${LIB_DIR}/awk/generate_map_macros.awk")
    
    # Format for template (pipe separated: count|macro)
    # Since the macro content is multi-line, we need to be careful
    # But mock_macros_header.h.tpl expects: count|macro
    # And it iterates over MAP_MACROS_DATA|newline_double
    # So we need to construct MAP_MACROS_DATA where each entry is separated by \n\n
    
    MAP_MACROS_DATA=""
    for count in "${param_counts_array[@]}"; do
        [ -z "$count" ] && continue
        local macro_def=$(echo "$count" | gawk -f "${LIB_DIR}/awk/generate_map_macros.awk")
        if [ -n "$MAP_MACROS_DATA" ]; then
            MAP_MACROS_DATA="${MAP_MACROS_DATA}"$'\n\n'"${count}|${macro_def}"
        else
            MAP_MACROS_DATA="${count}|${macro_def}"
        fi
    done
}

# Prepare NARGS data for template generation
# Generates data for _DAP_MOCK_NARGS macro generation
# Usage: prepare_nargs_data MAX_ARGS_COUNT
# Output: Sets NARGS_SEQUENCE and NARGS_IMPL_PARAMS variables
# Always generates full implementation (never simplified version)
prepare_nargs_data() {
    local max_args_count="$1"
    [ -z "$max_args_count" ] && max_args_count=0
    [ "$max_args_count" -lt 0 ] && max_args_count=0
    
    # Always ensure minimum of 2 args for full implementation
    # This ensures we always have a proper _DAP_MOCK_NARGS_IMPL definition
    # Minimum needed: _1, _2 for proper macro expansion
    local effective_max_args=$max_args_count
    [ "$effective_max_args" -lt 2 ] && effective_max_args=2
    
    # Prepare NARGS_SEQUENCE (always includes at least 2, 1, 0)
    NARGS_SEQUENCE=""
    for i in $(seq $effective_max_args -1 0); do
        if [ -n "$NARGS_SEQUENCE" ]; then
            NARGS_SEQUENCE="${NARGS_SEQUENCE}, $i"
        else
            NARGS_SEQUENCE=", $i"
        fi
    done
    
    # Prepare NARGS_IMPL_PARAMS (always includes at least _1, _2)
    # Format: single line with comma-separated parameters: _1, _2, _3, ...
    NARGS_IMPL_PARAMS=""
    for i in $(seq 1 $effective_max_args); do
        if [ -n "$NARGS_IMPL_PARAMS" ]; then
            NARGS_IMPL_PARAMS="${NARGS_IMPL_PARAMS}, _$i"
        else
            NARGS_IMPL_PARAMS="_$i"
        fi
    done
}

# Prepare MAP_COUNT_PARAMS_BY_COUNT_DATA for template generation
prepare_map_count_params_by_count_data() {
    local max_args_count="$1"
    [ -z "$max_args_count" ] && max_args_count=2
    [ "$max_args_count" -lt 2 ] && max_args_count=2
    
    MAP_COUNT_PARAMS_BY_COUNT_DATA=""
    for arg_count in $(seq 0 "$max_args_count"); do
        if [ -n "$MAP_COUNT_PARAMS_BY_COUNT_DATA" ]; then
            MAP_COUNT_PARAMS_BY_COUNT_DATA="${MAP_COUNT_PARAMS_BY_COUNT_DATA}"$'\n'"${arg_count}"
        else
            MAP_COUNT_PARAMS_BY_COUNT_DATA="${arg_count}"
        fi
    done
}

# Prepare MAP_COUNT_PARAMS_HELPER_DATA for template generation
# Format: arg_count|param_count
prepare_map_count_params_helper_data() {
    local max_args_count="$1"
    [ -z "$max_args_count" ] && max_args_count=2
    [ "$max_args_count" -lt 2 ] && max_args_count=2
    
    MAP_COUNT_PARAMS_HELPER_DATA=""
    for arg_count in $(seq 0 "$max_args_count"); do
        param_count=$((arg_count / 2))
        if [ -n "$MAP_COUNT_PARAMS_HELPER_DATA" ]; then
            MAP_COUNT_PARAMS_HELPER_DATA="${MAP_COUNT_PARAMS_HELPER_DATA}"$'\n'"${arg_count}|${param_count}"
        else
            MAP_COUNT_PARAMS_HELPER_DATA="${arg_count}|${param_count}"
        fi
    done
}
