# DAP Events Module (dap_events.h)

## Обзор

Модуль `dap_events.h` является основным интерфейсом системы асинхронных событий DAP SDK. Он предоставляет высокоуровневый API для инициализации, управления и координации многопоточной обработки событий.

## Архитектурная роль

Модуль `dap_events` играет центральную роль в экосистеме DAP:

```
┌─────────────────┐    ┌─────────────────┐
│   Приложение    │───▶│   dap_events    │
└─────────────────┘    └─────────────────┘
                              │
                    ┌─────────┼─────────┐
                    │         │         │
            ┌───────▼───┐ ┌──▼───┐ ┌───▼────┐
            │ dap_worker │ │ ... │ │ dap_worker │
            └────────────┘ └─────┘ └────────────┘
                    │         │         │
            ┌───────▼───┐ ┌──▼───┐ ┌───▼────┐
            │dap_context │ │ ... │ │dap_context │
            └────────────┘ └─────┘ └────────────┘
```

## Основные функции

### Инициализация и деинициализация

#### `dap_events_init()`
```c
int dap_events_init(uint32_t a_threads_count, size_t a_conn_timeout);
```

**Параметры:**
- `a_threads_count` - количество рабочих потоков (обычно = количеству CPU ядер)
- `a_conn_timeout` - таймаут соединения в миллисекундах

**Возвращаемые значения:**
- `0` - успешная инициализация
- `-1` - ошибка инициализации

**Пример:**
```c
if (dap_events_init(4, 30000) != 0) {
    fprintf(stderr, "Failed to initialize events system\n");
    exit(1);
}
```

#### `dap_events_deinit()`
```c
void dap_events_deinit();
```

Деинициализирует всю систему событий, освобождая все ресурсы.

### Управление жизненным циклом

#### `dap_events_start()`
```c
int32_t dap_events_start();
```

Запускает обработку событий во всех рабочих потоках.

**Возвращаемые значения:**
- `0` - успешный запуск
- `-1` - ошибка запуска

#### `dap_events_stop_all()`
```c
void dap_events_stop_all();
```

Останавливает все рабочие потоки и прекращает обработку событий.

#### `dap_events_wait()`
```c
int32_t dap_events_wait();
```

Блокирует вызывающий поток до завершения всех рабочих потоков.

### Управление рабочими потоками

#### `dap_events_worker_get_auto()`
```c
dap_worker_t *dap_events_worker_get_auto();
```

Возвращает автоматически выбранный рабочий поток для балансировки нагрузки.

**Возвращаемое значение:**
- Указатель на рабочий поток с минимальной нагрузкой

#### `dap_events_worker_get()`
```c
dap_worker_t *dap_events_worker_get(uint8_t a_index);
```

Возвращает рабочий поток по индексу.

#### `dap_events_thread_get_count()`
```c
uint32_t dap_events_thread_get_count();
```

Возвращает общее количество рабочих потоков.

#### `dap_events_thread_get_index_min()`
```c
uint32_t dap_events_thread_get_index_min();
```

Возвращает индекс рабочего потока с минимальной нагрузкой.

### Системная информация

#### `dap_get_cpu_count()`
```c
uint32_t dap_get_cpu_count();
```

Возвращает количество доступных CPU ядер в системе.

#### `dap_cpu_assign_thread_on()`
```c
void dap_cpu_assign_thread_on(uint32_t a_cpu_id);
```

Привязывает текущий поток к указанному CPU ядру.

### Статус и отладка

#### `dap_events_workers_init_status()`
```c
bool dap_events_workers_init_status();
```

Проверяет статус инициализации рабочих потоков.

**Возвращаемое значение:**
- `true` - все рабочие потоки инициализированы
- `false` - есть неинициализированные потоки

#### `dap_worker_print_all()`
```c
void dap_worker_print_all();
```

Выводит отладочную информацию о всех рабочих потоках.

## Глобальные переменные

### `g_debug_reactor`
```c
extern bool g_debug_reactor;
```

Флаг включения отладочного режима для реактора событий. При установке в `true` выводит дополнительную отладочную информацию.

## Алгоритм работы

### 1. Инициализация
```
Приложение → dap_events_init()
    ↓
Создание рабочих потоков
    ↓
Инициализация контекстов
    ↓
Настройка платформенно-зависимых механизмов
```

### 2. Обработка событий
```
Входящее событие → Автоматический выбор рабочего потока
    ↓
Добавление в очередь рабочего потока
    ↓
Обработка в контексте рабочего потока
    ↓
Выполнение callback функций
```

### 3. Балансировка нагрузки
```
Мониторинг нагрузки рабочих потоков
    ↓
Распределение новых соединений
    ↓
Перераспределение при перегрузке
```

## Платформенные особенности

### Linux (epoll)
- Использует `epoll_create()` для создания дескриптора
- Поддержка edge-triggered (`EPOLLET`) и level-triggered режимов
- Максимальное количество событий: 8192

### macOS/FreeBSD (kqueue)
- Использует `kqueue()` для создания очереди событий
- Поддержка различных фильтров событий
- Оптимизирован для сетевых приложений

### Windows (IOCP)
- Использует I/O Completion Ports
- Асинхронные операции overlapped I/O
- Высокая эффективность для большого количества соединений

## Производительность

### Оптимизации
- **Lock-free очереди** для межпоточного взаимодействия
- **Автоматическая балансировка** нагрузки между потоками
- **Платформенно-оптимизированные** механизмы опроса
- **Минимальные накладные расходы** на переключение контекстов

### Рекомендации по настройке
- **Количество потоков:** обычно равно количеству CPU ядер
- **Для I/O-bound:** 1.5-2x количества ядер
- **Для CPU-bound:** равно количеству ядер
- **Таймаут соединения:** 30-300 секунд в зависимости от типа приложения

## Интеграция

### С dap_worker
```c
// Получение рабочего потока через events
dap_worker_t *worker = dap_events_worker_get_auto();

// Использование в контексте worker
dap_worker_add_events_socket(worker, socket);
```

### С dap_context
```c
// Создание контекста для рабочего потока
dap_context_t *context = dap_context_new(DAP_CONTEXT_TYPE_WORKER);

// Запуск в системе событий
dap_context_run(context, cpu_id, policy, priority, flags,
                callback_started, callback_stopped, arg);
```

## Отладка и мониторинг

### Включение отладки
```c
g_debug_reactor = true;  // Включить отладочный вывод
```

### Мониторинг состояния
```c
// Проверка статуса инициализации
if (!dap_events_workers_init_status()) {
    log_error("Workers not properly initialized");
}

// Вывод информации о потоках
dap_worker_print_all();
```

## Лучшие практики

### 1. Инициализация
```c
// Всегда проверяйте результат инициализации
if (dap_events_init(cpu_count, 30000) != 0) {
    // Обработка ошибки
}

// Правильная последовательность запуска
dap_events_start();
// ... основная логика приложения ...
dap_events_wait();
```

### 2. Управление ресурсами
```c
// Всегда деинициализируйте систему
atexit([]() {
    dap_events_stop_all();
    dap_events_deinit();
});
```

### 3. Обработка ошибок
```c
// Проверяйте статус рабочих потоков
if (!dap_events_workers_init_status()) {
    // Логирование и восстановление
}
```

## Типичные проблемы

### 1. Недостаточное количество потоков
```
Симптом: Высокая загрузка CPU, низкая пропускная способность
Решение: Увеличить количество рабочих потоков
```

### 2. Неправильная привязка к CPU
```
Симптом: Неравномерная загрузка ядер
Решение: Проверить функцию dap_cpu_assign_thread_on()
```

### 3. Таймауты соединений
```
Симптом: Частые разрывы соединений
Решение: Увеличить значение conn_timeout
```

## Заключение

Модуль `dap_events` предоставляет надежный и эффективный фундамент для асинхронной обработки событий в DAP SDK. Его гибкая архитектура обеспечивает высокую производительность и масштабируемость для широкого спектра приложений.

