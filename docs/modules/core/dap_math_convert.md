# DAP Mathematical Conversions (Математические преобразования)

## Обзор

Модуль `dap_math_convert` предоставляет функции для преобразования между различными числовыми форматами, используемыми в DAP SDK. Основной фокус на работе с криптовалютными значениями и большими целыми числами.

## Назначение

В блокчейн системах часто требуется работа с большими числами (uint256, uint128) для представления криптовалютных значений с высокой точностью. Этот модуль обеспечивает конвертацию между строковыми представлениями и бинарными форматами.

## Основные возможности

- **Конвертация строк в uint256**: Поддержка десятичных и шестнадцатеричных форматов
- **Конвертация uint256 в строки**: Форматированный вывод с заданной точностью
- **Работа с фиксированной точкой**: Преобразование между целыми и дробными значениями
- **Валидация входных данных**: Проверка корректности строковых представлений

## Константы и определения

```c
// Степень для конвертации DATOSHI (минимальная единица)
#define DATOSHI_DEGREE 18
#define DATOSHI_POW 39
#define DATOSHI_POW256 (DATOSHI_POW * 2)

// Максимальная длина строк для различных типов
#define DAP_CHAIN$SZ_MAX128DEC 39  // "340282366920938463463374607431768211455"
#define DAP_CHAIN$SZ_MAX256DEC 78  // 2^256 в десятичном формате

// Множитель для конвертации DATOSHI
#define DATOSHI_MULT UINT64_C(1000000000000000000)
```

## API Функции

### Конвертация строк в числа

```c
// Конвертация строки в uint256_t (целое число)
uint256_t dap_uint256_scan_uninteger(const char *a_str_uninteger);

// Конвертация строки в uint256_t (десятичное число с плавающей точкой)
uint256_t dap_uint256_scan_decimal(const char *a_str_decimal);

// Конвертация строки в uint128_t
uint128_t dap_uint128_scan_uninteger(const char *a_str_uninteger);
uint128_t dap_uint128_scan_decimal(const char *a_str_decimal);
```

### Конвертация чисел в строки

```c
// Конвертация uint256_t в строку (целое число)
char *dap_uint256_uninteger_to_char(uint256_t a_uninteger);

// Конвертация uint256_t в строку (десятичное число)
char *dap_uint256_decimal_to_char(uint256_t a_decimal);

// Конвертация с округлением до заданного количества знаков
const char *dap_uint256_decimal_to_round_char(uint256_t a_uint256, uint8_t a_digits_after_point, bool is_round);

// Конвертация uint128_t в строки
char *dap_uint128_uninteger_to_char(uint128_t a_uninteger);
char *dap_uint128_decimal_to_char(uint128_t a_decimal);
```

### Служебные функции

```c
// Конвертация между uint256 и uint128
uint128_t dap_uint256_to_uint128(uint256_t a_from);
uint64_t dap_uint256_to_uint64(uint256_t a_from);
uint64_t dap_uint128_to_uint64(uint128_t a_from);

// Парсинг ID из строки
int dap_id_uint64_parse(const char *a_id_str, uint64_t *a_id);
```

## Использование

### Работа с криптовалютными значениями

```c
#include "dap_math_convert.h"

// Конвертация строки в криптовалютное значение
const char *amount_str = "1.234567890123456789";  // 1.234567890123456789 токенов
uint256_t amount = dap_uint256_scan_decimal(amount_str);

// Конвертация обратно в строку для отображения
char *display_str = dap_uint256_decimal_to_char(amount);
printf("Amount: %s tokens\n", display_str);
free(display_str);
```

### Работа с большими целыми числами

```c
// Работа с большими целыми числами (например, supply токена)
const char *supply_str = "1000000000000000000000000";  // 1 млн токенов с 18 decimals
uint256_t total_supply = dap_uint256_scan_uninteger(supply_str);

// Проверка корректности парсинга
if (total_supply != 0) {
    printf("Total supply parsed successfully\n");
}
```

### Форматированный вывод с округлением

```c
// Вывод с округлением до 2 знаков после запятой
uint256_t price = dap_uint256_scan_decimal("123.456789");
const char *formatted = dap_uint256_decimal_to_round_char(price, 2, true);
printf("Price: %s\n", formatted);  // Выведет: "123.46"
```

## Особенности реализации

### Система DATOSHI

DAP SDK использует систему DATOSHI для представления дробных значений:

- **1 токен = 10^18 DATOSHI** (аналогично 1 ETH = 10^18 wei)
- **DATOSHI_MULT = 1,000,000,000,000,000,000** (10^18)
- Все дробные значения хранятся как целые числа в минимальных единицах

### Форматы строк

Модуль поддерживает несколько форматов входных строк:

1. **Целые числа**: `"1234567890123456789"`
2. **Десятичные числа**: `"123.4567890123456789"`
3. **Шестнадцатеричные числа**: `"0x123456789abcdef"`

### Обработка ошибок

- **Некорректные строки**: Функции возвращают 0 при ошибке парсинга
- **Переполнение**: Проверяется диапазон значений для целевых типов
- **NULL указатели**: Все функции проверяют входные параметры

## Производительность

- **Парсинг строк**: O(n) где n - длина строки
- **Форматирование**: O(1) для большинства операций
- **Память**: Функции выделяют память для выходных строк (требуется освобождение)

## Использование в DAP SDK

Модуль широко используется в:

- **Wallet модуле**: Конвертация балансов и сумм транзакций
- **Chain модуле**: Работа с токенами и их количествами
- **Exchange модуле**: Расчет курсов и комиссий
- **Transaction модуле**: Формирование и валидация сумм

## Связанные модули

- `dap_math_ops.h` - Дополнительные математические операции
- `dap_common.h` - Общие определения и макросы
- `dap_chain_common.h` - Блокчейн-специфичные типы данных

## Замечания по безопасности

- **Валидация входных данных**: Всегда проверяйте корректность входных строк
- **Освобождение памяти**: Строки, возвращаемые функциями, должны освобождаться вызывающим кодом
- **Переполнение**: Проверяйте диапазон значений при работе с большими числами
- **Локализация**: Функции не учитывают локальные настройки форматирования чисел

## Примеры ошибок и их обработка

```c
// Правильная обработка ошибок
uint256_t value = dap_uint256_scan_decimal(user_input);
if (value == 0) {
    // Проверить, была ли это ошибка или действительно 0
    if (strcmp(user_input, "0") != 0 && strcmp(user_input, "0.0") != 0) {
        fprintf(stderr, "Error parsing value: %s\n", user_input);
        return ERROR_INVALID_INPUT;
    }
}
```

## Отладка

Для отладки конвертаций можно использовать промежуточные проверки:

```c
uint256_t test_value = dap_uint256_scan_decimal("123.456");
printf("Parsed value: %s\n", dap_uint256_decimal_to_char(test_value));

// Проверка обратной конвертации
char *back_to_string = dap_uint256_decimal_to_char(test_value);
uint256_t round_trip = dap_uint256_scan_decimal(back_to_string);
assert(dap_uint256_compare(&test_value, &round_trip) == 0);
free(back_to_string);
```

Это позволяет убедиться в корректности конвертаций и отсутствии потерь точности.

