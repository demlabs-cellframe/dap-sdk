# DAP IO Module (dap_io.h)

## Обзор

Модуль `dap_io.h` является фундаментальным компонентом DAP SDK, предоставляющим высокопроизводительную асинхронную систему ввода-вывода и управления событиями. Этот модуль отвечает за:

- **Многопоточную обработку событий** - эффективное распределение нагрузки между потоками
- **Кроссплатформенную поддержку** - работа на Windows, Linux, macOS и BSD
- **Масштабируемую архитектуру** - поддержка тысяч одновременных соединений
- **Оптимизированные механизмы опроса** - epoll, kqueue, IOCP в зависимости от платформы

## Архитектура

### Основные компоненты

#### 1. **dap_events** - Система событий
Основной интерфейс для инициализации и управления системой событий:

```c
// Инициализация системы событий
int dap_events_init(uint32_t a_threads_count, size_t a_conn_timeout);

// Запуск обработки событий
int32_t dap_events_start();

// Остановка всех потоков
void dap_events_stop_all();
```

#### 2. **dap_worker** - Рабочий поток
Представляет собой отдельный поток обработки событий:

```c
typedef struct dap_worker {
    uint32_t id;                           // Уникальный идентификатор
    dap_proc_thread_t *proc_queue_input;   // Очередь обработки
    dap_context_t *context;               // Контекст выполнения
    // ... дополнительные поля для очередей
} dap_worker_t;
```

#### 3. **dap_context** - Контекст выполнения
Абстракция для управления потоками и их ресурсами:

```c
typedef struct dap_context {
    uint32_t id;              // ID контекста
    pthread_t thread_id;      // ID потока
    int type;                 // Тип контекста
    bool is_running;          // Статус выполнения
    // ... платформенно-зависимые поля
} dap_context_t;
```

## Ключевые возможности

### Многопоточность и балансировка нагрузки

```c
// Получение количества доступных CPU
uint32_t dap_get_cpu_count();

// Привязка потока к конкретному CPU
void dap_cpu_assign_thread_on(uint32_t a_cpu_id);

// Автоматическое распределение нагрузки
dap_worker_t *dap_events_worker_get_auto();
```

### Управление сокетами событий

```c
// Добавление сокета в рабочий поток
void dap_worker_add_events_socket(dap_worker_t *a_worker,
                                  dap_events_socket_t *a_events_socket);

// Автоматическое добавление сокета
dap_worker_t *dap_worker_add_events_socket_auto(dap_events_socket_t *a_es);
```

### Таймеры и обратные вызовы

```c
// Выполнение callback в рабочем потоке
void dap_worker_exec_callback_on(dap_worker_t *a_worker,
                                 dap_worker_callback_t a_callback,
                                 void *a_arg);
```

## Платформенная поддержка

### Linux (epoll)
- Использует epoll для эффективного опроса событий
- Поддержка edge-triggered и level-triggered режимов
- Оптимизирован для большого количества дескрипторов

### macOS/FreeBSD (kqueue)
- Использует kqueue для управления событиями
- Поддержка фильтров для различных типов событий
- Высокая производительность для сетевых приложений

### Windows (IOCP)
- Использует I/O Completion Ports
- Асинхронные операции ввода-вывода
- Оптимизирован для overlapped операций

## Производительность и масштабируемость

### Оптимизации
- **Lock-free структуры данных** для очередей
- **Масштабируемые хэш-таблицы** для поиска сокетов
- **Платформенно-оптимизированные** механизмы опроса
- **Автоматическая балансировка** нагрузки между потоками

### Лимиты и конфигурация
```c
#define DAP_MAX_EVENTS_COUNT 8192  // Максимальное количество событий
#define DAP_EVENTS_SOCKET_MAX 1024 // Максимальное количество сокетов на контекст
```

## Использование

### Базовая инициализация

```c
#include "dap_events.h"
#include "dap_worker.h"

// Инициализация системы
if (dap_events_init(4, 30000) != 0) {  // 4 потока, таймаут 30 сек
    fprintf(stderr, "Failed to initialize events system\n");
    return -1;
}

// Запуск обработки
if (dap_events_start() != 0) {
    fprintf(stderr, "Failed to start events processing\n");
    return -1;
}

// Основной цикл приложения
dap_events_wait();

// Деинициализация
dap_events_deinit();
```

### Работа с рабочими потоками

```c
// Получение текущего рабочего потока
dap_worker_t *current_worker = dap_worker_get_current();

// Получение автоматического рабочего потока
dap_worker_t *auto_worker = dap_events_worker_get_auto();

// Выполнение задачи в конкретном потоке
dap_worker_exec_callback_on(auto_worker, my_callback, my_data);
```

## Интеграция с другими модулями

### DAP Net
IO модуль является фундаментом для сетевого модуля DAP, предоставляя:
- Асинхронную обработку сетевых соединений
- Балансировку нагрузки между потоками
- Оптимизированные механизмы опроса

### DAP Server
Взаимодействует с серверным модулем для:
- Обработки входящих соединений
- Управления таймаутами соединений
- Распределения нагрузки

### DAP Client
Обеспечивает асинхронную работу клиентских соединений:
- Неблокирующие операции чтения/записи
- Управление множественными соединениями
- Обработку таймаутов

## Отладка и мониторинг

### Отладочные возможности
```c
extern bool g_debug_reactor;  // Включение отладки реактора

// Вывод информации о всех рабочих потоках
void dap_worker_print_all();
```

### Статистика и метрики
- Количество активных соединений
- Загрузка рабочих потоков
- Статистика очередей обработки
- Время отклика на события

## Лучшие практики

### 1. Конфигурация потоков
- Устанавливайте количество потоков равным количеству CPU ядер
- Для I/O-bound приложений используйте 1.5-2x количества ядер
- Мониторьте загрузку потоков для оптимизации

### 2. Управление ресурсами
- Всегда вызывайте `dap_events_deinit()` при завершении
- Используйте автоматическое распределение для новых сокетов
- Мониторьте использование памяти очередей

### 3. Обработка ошибок
- Проверяйте коды возврата всех функций
- Обрабатывайте таймауты соединений
- Логируйте критические ошибки системы событий

## Заключение

IO модуль DAP SDK предоставляет высокопроизводительную, кроссплатформенную систему асинхронного ввода-вывода, которая является фундаментом для всех сетевых операций в экосистеме DAP. Его архитектура обеспечивает масштабируемость и эффективность, необходимые для высоконагруженных приложений.
