#!/usr/bin/env python3
"""
DAP SDK Mock Auto-Wrapper Generator
Automatically scans test source files for mock declarations and generates:
1. Linker response file with --wrap options
2. Wrapper implementations
3. CMake integration

Usage:
    ./dap_mock_autowrap.py <test_source.c> [output_dir]
"""

import re
import sys
import os
from pathlib import Path
from typing import List, Set, Tuple, Dict

class MockAutoWrapper:
    """Automatic mock wrapper generator for DAP SDK tests"""
    
    def __init__(self, test_source: str, output_dir: str = None):
        self.test_source = Path(test_source)
        self.output_dir = Path(output_dir) if output_dir else self.test_source.parent
        self.mock_functions: Set[str] = set()
        self.wrapper_info: Dict[str, dict] = {}
        
    def scan_mock_declarations(self) -> Set[str]:
        """Scan test source for DAP_MOCK_DECLARE() calls"""
        print(f"üìã Scanning {self.test_source} for mock declarations...")
        
        with open(self.test_source, 'r') as f:
            content = f.read()
        
        # Find all DAP_MOCK_DECLARE(function_name)
        pattern = r'DAP_MOCK_DECLARE\s*\(\s*(\w+)\s*\)'
        matches = re.findall(pattern, content)
        
        self.mock_functions = set(matches)
        print(f"‚úÖ Found {len(self.mock_functions)} mock declarations:")
        for func in sorted(self.mock_functions):
            print(f"   - {func}")
        
        return self.mock_functions
    
    def scan_wrapper_definitions(self) -> Dict[str, dict]:
        """Scan for existing wrapper definitions to get signatures"""
        print(f"\nüìã Scanning for wrapper definitions...")
        
        with open(self.test_source, 'r') as f:
            content = f.read()
        
        # Match DAP_MOCK_WRAPPER_* macros
        pattern = r'DAP_MOCK_WRAPPER_(\w+)\s*\(\s*(\w+)\s*,\s*\(([^)]+)\)\s*,\s*\(([^)]+)\)\s*\)'
        matches = re.findall(pattern, content)
        
        for wrapper_type, func_name, params, args in matches:
            self.wrapper_info[func_name] = {
                'type': wrapper_type,
                'params': params.strip(),
                'args': args.strip()
            }
            print(f"   ‚úÖ {func_name}: {wrapper_type} wrapper found")
        
        return self.wrapper_info
    
    def generate_linker_response_file(self) -> Path:
        """Generate linker response file with --wrap options"""
        response_file = self.output_dir / f"{self.test_source.stem}_wrap.txt"
        
        print(f"\nüìù Generating linker response file: {response_file}")
        
        with open(response_file, 'w') as f:
            for func in sorted(self.mock_functions):
                f.write(f"-Wl,--wrap={func}\n")
        
        print(f"‚úÖ Generated {len(self.mock_functions)} --wrap options")
        return response_file
    
    def generate_cmake_integration(self) -> Path:
        """Generate CMake fragment for integration"""
        cmake_file = self.output_dir / f"{self.test_source.stem}_mocks.cmake"
        
        print(f"\nüìù Generating CMake integration: {cmake_file}")
        
        test_name = self.test_source.stem
        response_file = f"{test_name}_wrap.txt"
        
        with open(cmake_file, 'w') as f:
            f.write(f"# Auto-generated mock configuration for {test_name}\n")
            f.write(f"# Generated by dap_mock_autowrap.py\n\n")
            f.write(f"# Linker wrapping options\n")
            f.write(f"set({test_name.upper()}_WRAP_FILE\n")
            f.write(f"    ${{CMAKE_CURRENT_SOURCE_DIR}}/{response_file}\n")
            f.write(f")\n\n")
            f.write(f"# Read wrap options from file\n")
            f.write(f"file(READ ${{{test_name.upper()}_WRAP_FILE}} {test_name.upper()}_WRAP_OPTIONS)\n")
            f.write(f"string(REPLACE \"\\n\" \";\" {test_name.upper()}_WRAP_LIST \"${{{test_name.upper()}_WRAP_OPTIONS}}\")\n\n")
            f.write(f"# Apply to test target\n")
            f.write(f"target_link_options({test_name} PRIVATE\n")
            f.write(f"    ${{{test_name.upper()}_WRAP_LIST}}\n")
            f.write(f")\n\n")
            f.write(f"# Wrapped functions (for documentation):\n")
            for func in sorted(self.mock_functions):
                f.write(f"#   - {func}\n")
        
        print(f"‚úÖ Generated CMake integration")
        return cmake_file
    
    def generate_wrapper_template(self) -> Path:
        """Generate template for missing wrappers"""
        missing_wrappers = self.mock_functions - set(self.wrapper_info.keys())
        
        if not missing_wrappers:
            print(f"\n‚úÖ All wrappers are defined, no template needed")
            return None
        
        template_file = self.output_dir / f"{self.test_source.stem}_wrappers_template.c"
        
        print(f"\n‚ö†Ô∏è  Missing wrappers for {len(missing_wrappers)} functions")
        print(f"üìù Generating template: {template_file}")
        
        with open(template_file, 'w') as f:
            f.write(f"// Auto-generated wrapper templates for {self.test_source.name}\n")
            f.write(f"// Copy these to your test file and fill in parameter types\n\n")
            f.write(f"#include \"dap_mock_framework.h\"\n")
            f.write(f"#include \"dap_mock_linker_wrapper.h\"\n\n")
            
            for func in sorted(missing_wrappers):
                f.write(f"// TODO: Define wrapper for {func}\n")
                f.write(f"// Example:\n")
                f.write(f"// DAP_MOCK_WRAPPER_INT({func},\n")
                f.write(f"//     (type1 a_param1, type2 a_param2),\n")
                f.write(f"//     (a_param1, a_param2))\n\n")
        
        print(f"‚úÖ Template generated with {len(missing_wrappers)} function stubs")
        for func in sorted(missing_wrappers):
            print(f"   ‚ö†Ô∏è  {func}")
        
        return template_file
    
    def generate_all(self):
        """Main entry point - generate all files"""
        print("="*60)
        print("DAP SDK Mock Auto-Wrapper Generator")
        print("="*60)
        
        # Step 1: Scan for mock declarations
        self.scan_mock_declarations()
        
        # Step 2: Scan for existing wrappers
        self.scan_wrapper_definitions()
        
        # Step 3: Generate linker response file
        response_file = self.generate_linker_response_file()
        
        # Step 4: Generate CMake integration
        cmake_file = self.generate_cmake_integration()
        
        # Step 5: Generate wrapper template if needed
        template_file = self.generate_wrapper_template()
        
        # Summary
        print("\n" + "="*60)
        print("‚úÖ Generation Complete!")
        print("="*60)
        print(f"\nGenerated files:")
        print(f"  üìÑ {response_file}")
        print(f"  üìÑ {cmake_file}")
        if template_file:
            print(f"  üìÑ {template_file}")
        
        print(f"\nTo use in CMakeLists.txt:")
        print(f"  include({cmake_file.name})")
        
        return {
            'response_file': response_file,
            'cmake_file': cmake_file,
            'template_file': template_file
        }

def main():
    if len(sys.argv) < 2:
        print("Usage: dap_mock_autowrap.py <test_source.c> [output_dir]")
        sys.exit(1)
    
    test_source = sys.argv[1]
    output_dir = sys.argv[2] if len(sys.argv) > 2 else None
    
    if not os.path.exists(test_source):
        print(f"Error: File not found: {test_source}")
        sys.exit(1)
    
    generator = MockAutoWrapper(test_source, output_dir)
    generator.generate_all()

if __name__ == '__main__':
    main()

