#!/bin/bash
# Generate output files (wrap, cmake, macros, templates)

# Source common utilities (but don't initialize yet - that's done in main script)
LIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${LIB_DIR}/dap_mock_common.sh"

# Generate linker response file with --wrap options
generate_wrap_file() {
    local wrap_file="$1"
    local mock_functions="$2"
    
    > "$wrap_file"  # Clear file
    if [ -n "$mock_functions" ]; then
        local func_count=$(echo "$mock_functions" | wc -l)
        echo "$mock_functions" | while read func; do
            # Note: For -Wl,@file usage, we need just --wrap=func (without -Wl,)
            echo "--wrap=$func" >> "$wrap_file"
        done
        print_success "Generated $func_count --wrap options"
    else
        # Create truly empty file - linker response files cannot contain comments
        > "$wrap_file"
        print_info "Created empty wrap file (no mocks to wrap)"
    fi
}

# Generate CMake integration file
generate_cmake_file() {
    local cmake_file="$1"
    local mock_functions="$2"
    
    cat > "$cmake_file" << EOF
# Auto-generated mock configuration
# Generated by dap_mock_autowrap.sh

# Wrapped functions:
EOF

    if [ -n "$mock_functions" ]; then
        echo "$mock_functions" | while read func; do
            echo "#   - $func" >> "$cmake_file"
        done
    else
        echo "#   (none - no mocks declared)" >> "$cmake_file"
    fi
    
    print_success "Generated CMake integration"
}

# Generate macros header file
generate_macros_file() {
    local macros_file="$1"
    local return_type_macros_file="${macros_file}.return_types"
    local simple_wrapper_macros_file="${macros_file}.simple_wrappers"
    
    # Generate return type macros using types module
    source "${LIB_DIR}/dap_mock_types.sh"
    generate_return_type_macros "$return_type_macros_file"
    
    # Generate simple wrapper macros (if needed)
    > "$simple_wrapper_macros_file"
    
    # Prepare template data
    prepare_nargs_data "$MAX_ARGS_COUNT"
    prepare_map_count_params_by_count_data "$MAX_ARGS_COUNT"
    prepare_map_count_params_helper_data "$MAX_ARGS_COUNT"
    prepare_map_impl_cond_1_data "$MAX_ARGS_COUNT" "${PARAM_COUNTS_ARRAY[@]}"
    prepare_map_impl_cond_data "${PARAM_COUNTS_ARRAY[@]}"
    prepare_map_macros_data "${PARAM_COUNTS_ARRAY[@]}"
    
    # Generate mock_map_macros content with template language constructs
    RETURN_TYPE_MACROS_FILE="$return_type_macros_file" \
    SIMPLE_WRAPPER_MACROS_FILE="$simple_wrapper_macros_file" \
    # Convert PARAM_COUNTS_ARRAY to pipe-separated string for dap_tpl for loop
    # dap_tpl for_evaluator expects pipe-separated or newline-separated arrays
    PARAM_COUNTS_ARRAY_PIPE=$(IFS='|'; echo "${PARAM_COUNTS_ARRAY[*]}")
    
    PARAM_COUNTS_ARRAY="${PARAM_COUNTS_ARRAY[*]}" \
    MAX_ARGS_COUNT="$MAX_ARGS_COUNT" \
    MAP_COUNT_PARAMS_BY_COUNT_DATA="$MAP_COUNT_PARAMS_BY_COUNT_DATA" \
    MAP_COUNT_PARAMS_HELPER_DATA="$MAP_COUNT_PARAMS_HELPER_DATA" \
    MAP_IMPL_COND_1_DATA="$MAP_IMPL_COND_1_DATA" \
    MAP_IMPL_COND_DATA="$MAP_IMPL_COND_DATA" \
    replace_template_placeholders_with_mocking \
        "${TEMPLATES_DIR}/mock_map_macros.h.tpl" \
        "${macros_file}.map_content" \
        "RETURN_TYPE_MACROS_FILE=$return_type_macros_file" \
        "SIMPLE_WRAPPER_MACROS_FILE=$simple_wrapper_macros_file" \
        "PARAM_COUNTS_ARRAY=$PARAM_COUNTS_ARRAY_PIPE" \
        "MAX_ARGS_COUNT=$MAX_ARGS_COUNT" \
        "MAP_COUNT_PARAMS_BY_COUNT_DATA=$MAP_COUNT_PARAMS_BY_COUNT_DATA" \
        "MAP_COUNT_PARAMS_HELPER_DATA=$MAP_COUNT_PARAMS_HELPER_DATA" \
        "MAP_IMPL_COND_1_DATA=$MAP_IMPL_COND_1_DATA" \
        "MAP_IMPL_COND_DATA=$MAP_IMPL_COND_DATA"
    
    # Export file paths for template processing
    export RETURN_TYPE_MACROS_FILE="$return_type_macros_file"
    export SIMPLE_WRAPPER_MACROS_FILE="$simple_wrapper_macros_file"
    export MAP_MACROS_CONTENT_FILE="${macros_file}.map_content"
    
    # Verify files exist before template processing
    if [ ! -f "$RETURN_TYPE_MACROS_FILE" ]; then
        print_error "RETURN_TYPE_MACROS_FILE does not exist: $RETURN_TYPE_MACROS_FILE"
        return 1
    fi
    
    # Save file paths before they might be overwritten in function calls
    local saved_return_type_macros_file="$RETURN_TYPE_MACROS_FILE"
    local saved_simple_wrapper_macros_file="$SIMPLE_WRAPPER_MACROS_FILE"
    
    if [ -n "$saved_return_type_macros_file" ] && [ -f "$saved_return_type_macros_file" ] && [ -s "$saved_return_type_macros_file" ]; then
        # First generate template without return type macros
        # Convert PARAM_COUNTS_ARRAY to pipe-separated string for dap_tpl for loop
        PARAM_COUNTS_ARRAY_PIPE=$(IFS='|'; echo "${PARAM_COUNTS_ARRAY[*]}")
        
        replace_template_placeholders_with_mocking \
            "${TEMPLATES_DIR}/mock_macros_header.h.tpl" \
            "$macros_file" \
            "MAX_ARGS_COUNT=$MAX_ARGS_COUNT" \
            "PARAM_COUNTS_ARRAY=$PARAM_COUNTS_ARRAY_PIPE" \
            "NARGS_SEQUENCE=$NARGS_SEQUENCE" \
            "NARGS_IMPL_PARAMS=$NARGS_IMPL_PARAMS" \
            "MAP_MACROS_DATA=$MAP_MACROS_DATA" \
            "MAP_MACROS_CONTENT_FILE=${MAP_MACROS_CONTENT_FILE}" \
            "RETURN_TYPE_MACROS_FILE=" \
            "SIMPLE_WRAPPER_MACROS_FILE=$saved_simple_wrapper_macros_file"
        
        # Append return type macros directly
        cat "$saved_return_type_macros_file" >> "$macros_file"
        
        # Append simple wrapper macros if they exist
        if [ -n "$saved_simple_wrapper_macros_file" ] && [ -f "$saved_simple_wrapper_macros_file" ] && [ -s "$saved_simple_wrapper_macros_file" ]; then
            cat "$saved_simple_wrapper_macros_file" >> "$macros_file"
        fi
    else
        # No return types - use normal template processing
        # Convert PARAM_COUNTS_ARRAY to pipe-separated string for dap_tpl for loop
        PARAM_COUNTS_ARRAY_PIPE=$(IFS='|'; echo "${PARAM_COUNTS_ARRAY[*]}")
        
        replace_template_placeholders_with_mocking \
            "${TEMPLATES_DIR}/mock_macros_header.h.tpl" \
            "$macros_file" \
            "MAX_ARGS_COUNT=$MAX_ARGS_COUNT" \
            "PARAM_COUNTS_ARRAY=$PARAM_COUNTS_ARRAY_PIPE" \
            "NARGS_SEQUENCE=$NARGS_SEQUENCE" \
            "NARGS_IMPL_PARAMS=$NARGS_IMPL_PARAMS" \
            "MAP_MACROS_DATA=$MAP_MACROS_DATA" \
            "MAP_MACROS_CONTENT_FILE=${MAP_MACROS_CONTENT_FILE}" \
            "RETURN_TYPE_MACROS_FILE=$return_type_macros_file" \
            "SIMPLE_WRAPPER_MACROS_FILE=$simple_wrapper_macros_file"
    fi
    
    # Clean up temporary files AFTER template processing is complete
    # Note: map_content file is included via {{#include}}, so it must exist during template processing
    # It will be cleaned up after the final template is generated
    rm -f "$return_type_macros_file" "$simple_wrapper_macros_file"
    # Keep map_content file for now - it's needed for include processing
    # It will be cleaned up later if needed
    
    print_success "Generated macros header with ${#PARAM_COUNTS_ARRAY[@]} parameter count(s)"
    if [ -n "$RETURN_TYPES" ]; then
        local return_types_count=$(echo "$RETURN_TYPES" | wc -w)
        print_success "Generated specialized macros for $return_types_count return type(s): $RETURN_TYPES"
    fi
}

# Generate wrapper template file
generate_template_file() {
    local template_file="$1"
    local mock_functions="$2"
    local wrapper_functions="$3"
    
    if [ -z "$mock_functions" ]; then
        print_info "No mocks declared - skipping template generation"
        return 0
    elif [ -n "$wrapper_functions" ]; then
        local missing_functions=$(comm -23 <(echo "$mock_functions" | sort) <(echo "$wrapper_functions" | sort))
        
        if [ -z "$missing_functions" ]; then
            print_success "All wrappers are defined"
            return 0
        else
            local missing_count=$(echo "$missing_functions" | wc -l)
            print_warning "Missing wrappers for $missing_count functions"
            print_info "Generating template: $template_file"
            
            # Generate template file using main template
            MISSING_FUNCTIONS="$missing_functions" \
            replace_template_placeholders_with_mocking \
                "${TEMPLATES_DIR}/wrapper_template.h.tpl" \
                "$template_file"
            
            # Show missing functions
            echo "$missing_functions" | while read func; do
                [ -z "$func" ] && continue
                echo "   ⚠️  $func"
            done
            
            print_success "Template generated with $missing_count function stubs"
        fi
    else
        # No wrappers found but mocks exist - generate template for all
        local func_count=$(echo "$mock_functions" | wc -l)
        print_warning "No wrappers found for $func_count functions"
        print_info "Generating template: $template_file"
        
        # Generate template file using main template
        MISSING_FUNCTIONS="$mock_functions" \
        replace_template_placeholders_with_mocking \
            "${TEMPLATES_DIR}/wrapper_template.h.tpl" \
            "$template_file"
        
        # Show missing functions
        echo "$mock_functions" | while read func; do
            [ -z "$func" ] && continue
            echo "   ⚠️  $func"
        done
        
        print_success "Template generated with $func_count function stubs"
    fi
}

# Generate custom mock headers for each custom mock declaration
# Usage: generate_custom_mock_headers <output_dir> <basename> <custom_mocks_file> <wrapper_functions>
generate_custom_mock_headers() {
    local output_dir="$1"
    local basename="$2"
    local custom_mocks_file="$3"
    local wrapper_functions="$4"
    local temp_files=()  # Track temporary files for cleanup
    
    if [ ! -f "$custom_mocks_file" ] || [ ! -s "$custom_mocks_file" ]; then
        print_info "No custom mocks found - creating custom mocks header with macros only"
        local main_custom_mocks_file="${output_dir}/${basename}_custom_mocks.h"
        
        # Generate empty main include file using template
        replace_template_placeholders_with_mocking \
            "${TEMPLATES_DIR}/custom_mocks_main_empty.h.tpl" \
            "$main_custom_mocks_file" \
            "BASENAME=$basename"
        return 0
    fi
    
    local custom_mocks_count=$(wc -l < "$custom_mocks_file" | tr -d ' ')
    
    # Create directory for custom mock headers
    local custom_mocks_dir="${output_dir}/custom_mocks"
    mkdir -p "$custom_mocks_dir"
    
    # Process each custom mock declaration
    while IFS='|' read -r return_type func_name param_list macro_type; do
        [ -z "$func_name" ] && continue
        
        # Skip if function already has a wrapper defined in source files
        if echo "$wrapper_functions" | grep -q "^${func_name}$"; then
            continue
        fi
        
        # Create header file name based on function name
        local header_file="${custom_mocks_dir}/${func_name}_mock.h"
        
        # Parse parameters from param_list
        local param_decl=""
        local param_names=""
        local param_array=""
        local param_count=0
        
        if [ "$param_list" = "void" ] || [ -z "$param_list" ]; then
            param_decl="void"
            param_names=""
            param_array="NULL"
            param_count=0
        else
            # Extract PARAM(type, name) entries
            local clean_params=$(echo "$param_list" | tr -d ' \t\n')
            param_count=$(echo "$clean_params" | grep -o "PARAM(" | wc -l)
            
            if [ "$param_count" -eq 0 ]; then
                param_decl="void"
                param_names=""
                param_array="NULL"
                param_count=0
            else
                # Extract each PARAM(type, name)
                local param_decl_parts=()
                local param_name_parts=()
                local param_array_parts=()
                
                # Use awk script to extract PARAM entries
                local tmp_params_file=$(create_temp_file "params_${func_name}")
                temp_files+=("$tmp_params_file")
                echo "$param_list" | gawk -f "${MOCK_AWK_DIR}/parse_params.awk" > "$tmp_params_file"
                
                # Read extracted parameters
                while IFS='|' read -r param_type param_name; do
                    [ -z "$param_type" ] && continue
                    param_decl_parts+=("$param_type $param_name")
                    param_name_parts+=("$param_name")
                    param_array_parts+=("(void*)(intptr_t)$param_name")
                done < "$tmp_params_file"
                
                # Join parameters with proper formatting
                if [ ${#param_decl_parts[@]} -gt 0 ]; then
                    param_decl=$(IFS=','; printf '%s, ' "${param_decl_parts[@]}" | sed 's/, $//')
                    param_names=$(IFS=','; printf '%s, ' "${param_name_parts[@]}" | sed 's/, $//')
                    param_array="((void*[]){$(IFS=','; printf '%s, ' "${param_array_parts[@]}" | sed 's/, $//')})"
                    param_count=${#param_decl_parts[@]}
                else
                    param_decl="void"
                    param_names=""
                    param_array="NULL"
                    param_count=0
                fi
            fi
        fi
        
        # Prepare template variables
        local guard_name="${func_name^^}_MOCK_H"
        local wrapper_signature=""
        local result_declaration=""
        local mock_impl_call=""
        local real_function_call=""
        local return_value_override=""
        local record_call=""
        local return_statement=""
        local return_value_override_file=""
        local record_call_file=""
        
        if [ "$return_type" = "void" ]; then
            wrapper_signature="void __wrap_${func_name}($param_decl)"
            result_declaration=""
            if [ "$param_count" -eq 0 ]; then
                mock_impl_call="        __mock_impl_${func_name}();"
                real_function_call="        __real_${func_name}();"
            else
                mock_impl_call="        __mock_impl_${func_name}($param_names);"
                real_function_call="        __real_${func_name}($param_names);"
            fi
            return_value_override=""
            record_call=""
            return_statement=""
        else
            wrapper_signature="$return_type __wrap_${func_name}($param_decl)"
            result_declaration="    $return_type __wrap_result = ($return_type){0};"
            if [ "$param_count" -eq 0 ]; then
                mock_impl_call="        __wrap_result = __mock_impl_${func_name}();"
                real_function_call="        __wrap_result = __real_${func_name}();"
            else
                mock_impl_call="        __wrap_result = __mock_impl_${func_name}($param_names);"
                real_function_call="        __wrap_result = __real_${func_name}($param_names);"
            fi
            # Create temporary files for multi-line values
            return_value_override_file=$(create_temp_file "return_value_override_${func_name}")
            record_call_file=$(create_temp_file "record_call_${func_name}")
            temp_files+=("$return_value_override_file" "$record_call_file")
            {
                echo "        if (__wrap_mock_state && __wrap_mock_state->return_value.ptr) {"
                echo "            __wrap_result = *($return_type*)__wrap_mock_state->return_value.ptr;"
                echo "        }"
            } > "$return_value_override_file"
            echo "        dap_mock_record_call(__wrap_mock_state, __wrap_args, __wrap_args_count, (void*)(intptr_t)__wrap_result);" > "$record_call_file"
            return_value_override="@$return_value_override_file"
            record_call="@$record_call_file"
            return_statement="    return __wrap_result;"
        fi
        
        # Generate header file using template
        replace_template_placeholders_with_mocking \
            "${TEMPLATES_DIR}/custom_mock_header.h.tpl" \
            "$header_file" \
            "FUNC_NAME=$func_name" \
            "RETURN_TYPE=$return_type" \
            "PARAM_DECL=$param_decl" \
            "PARAM_NAMES=$param_names" \
            "PARAM_ARRAY=$param_array" \
            "PARAM_COUNT=$param_count" \
            "GUARD_NAME=$guard_name" \
            "WRAPPER_FUNCTION_SIGNATURE=$wrapper_signature" \
            "RESULT_DECLARATION=$result_declaration" \
            "MOCK_IMPL_CALL=$mock_impl_call" \
            "RETURN_VALUE_OVERRIDE=$return_value_override" \
            "RECORD_CALL=$record_call" \
            "REAL_FUNCTION_CALL=$real_function_call" \
            "RETURN_STATEMENT=$return_statement"
        
        print_success "Generated mock header: $header_file"
    done < "$custom_mocks_file"
    
    # Clean up temporary files
    cleanup_temp_files "${temp_files[@]}"
    
    # Create main include file that includes all custom mock headers
    local main_custom_mocks_file="${output_dir}/${basename}_custom_mocks.h"
    
    # Generate main include file using template
    # Check if custom_mocks_file has any non-empty lines
    local non_empty_lines=$(grep -v '^[[:space:]]*$' "$custom_mocks_file" | wc -l)
    if [ "$non_empty_lines" -eq 0 ]; then
        # File is empty or contains only whitespace - use empty template
        replace_template_placeholders_with_mocking \
            "${TEMPLATES_DIR}/custom_mocks_main_empty.h.tpl" \
            "$main_custom_mocks_file" \
            "BASENAME=$basename"
    else
        export CUSTOM_MOCKS_LIST="$(cat "$custom_mocks_file")"
        export WRAPPER_FUNCTIONS="$wrapper_functions"
        replace_template_placeholders_with_mocking \
            "${TEMPLATES_DIR}/custom_mocks_main.h.tpl" \
            "$main_custom_mocks_file" \
            "BASENAME=$basename"
    fi
    
    print_success "Generated main custom mocks include: $main_custom_mocks_file"
}
