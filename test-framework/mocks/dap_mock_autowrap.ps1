# DAP SDK Mock Auto-Wrapper Generator (PowerShell version)
# Automatically scans test source files for mock declarations and generates:
# 1. Linker response file with --wrap options
# 2. CMake fragment with configuration
# 3. Wrapper template for missing wrappers
#
# Usage:
#   .\dap_mock_autowrap.ps1 <test_source.c> [output_dir]

param(
    [Parameter(Mandatory=$true)]
    [string]$TestSource,
    
    [Parameter(Mandatory=$false)]
    [string]$OutputDir
)

# Color functions
function Write-Header {
    param([string]$Message)
    Write-Host "============================================================" -ForegroundColor Cyan
    Write-Host $Message -ForegroundColor Cyan
    Write-Host "============================================================" -ForegroundColor Cyan
}

function Write-Info {
    param([string]$Message)
    Write-Host "üìã $Message" -ForegroundColor Blue
}

function Write-Success {
    param([string]$Message)
    Write-Host "‚úÖ $Message" -ForegroundColor Green
}

function Write-Warning2 {
    param([string]$Message)
    Write-Host "‚ö†Ô∏è  $Message" -ForegroundColor Yellow
}

function Write-ErrorMsg {
    param([string]$Message)
    Write-Host "‚ùå $Message" -ForegroundColor Red
}

# Check if file exists
if (-not (Test-Path $TestSource)) {
    Write-ErrorMsg "File not found: $TestSource"
    exit 1
}

# Determine output directory
if (-not $OutputDir) {
    $OutputDir = Split-Path -Parent $TestSource
}

# Extract base name
$BaseName = [System.IO.Path]::GetFileNameWithoutExtension($TestSource)
$SourceDir = Split-Path -Parent $TestSource

# Output files
$WrapFile = Join-Path $OutputDir "${BaseName}_wrap.txt"
$CMakeFile = Join-Path $OutputDir "${BaseName}_mocks.cmake"
$TemplateFile = Join-Path $OutputDir "${BaseName}_wrappers_template.c"

Write-Header "DAP SDK Mock Auto-Wrapper Generator (PowerShell)"

# Step 1: Scan for mock declarations
Write-Info "Scanning $TestSource for mock declarations..."

$Content = Get-Content -Path $TestSource -Raw

# Extract mock declarations using regex
# Match both DAP_MOCK_DECLARE(func_name) and DAP_MOCK_DECLARE_CUSTOM(func_name, ...)
$MockPattern1 = 'DAP_MOCK_DECLARE\s*\(\s*(\w+)\s*\)'
$MockPattern2 = 'DAP_MOCK_DECLARE_CUSTOM\s*\(\s*(\w+)\s*,'
$MockMatches1 = [regex]::Matches($Content, $MockPattern1)
$MockMatches2 = [regex]::Matches($Content, $MockPattern2)
$MockMatches = $MockMatches1 + $MockMatches2

if ($MockMatches.Count -eq 0) {
    Write-Info "No mock declarations found - will create empty wrap file"
    $MockFunctions = @()
} else {
    $MockFunctions = $MockMatches | ForEach-Object { $_.Groups[1].Value } | Sort-Object -Unique
    Write-Success "Found $($MockFunctions.Count) mock declarations:"
    foreach ($func in $MockFunctions) {
        Write-Host "   - $func"
    }
}

# Step 2: Scan for existing wrapper definitions
Write-Info "Scanning for wrapper definitions..."

# Match DAP_MOCK_WRAPPER_CUSTOM(return_type, func_name, ...)
# Extract func_name which is the second argument
$WrapperPattern1 = 'DAP_MOCK_WRAPPER_CUSTOM\s*\(\s*[^,]+\s*,\s*(\w+)\s*,'
$WrapperMatches1 = [regex]::Matches($Content, $WrapperPattern1)

# Also match explicit __wrap_ definitions
$WrapperPattern2 = '__wrap_(\w+)'
$WrapperMatches2 = [regex]::Matches($Content, $WrapperPattern2)

$WrapperFunctions = @()
if ($WrapperMatches1.Count -gt 0 -or $WrapperMatches2.Count -gt 0) {
    $Funcs1 = $WrapperMatches1 | ForEach-Object { $_.Groups[1].Value }
    $Funcs2 = $WrapperMatches2 | ForEach-Object { $_.Groups[1].Value }
    $WrapperFunctions = ($Funcs1 + $Funcs2) | Sort-Object -Unique
    
    foreach ($func in $WrapperFunctions) {
        Write-Host "   ‚úÖ ${func}: wrapper found"
    }
}

# Step 3: Generate linker response file
Write-Info "Generating linker response file: $WrapFile"

if ($MockFunctions.Count -gt 0) {
    $WrapContent = $MockFunctions | ForEach-Object { "-Wl,--wrap=$_" }
    $WrapContent -join "`n" | Out-File -FilePath $WrapFile -Encoding ASCII -NoNewline
    "`n" | Out-File -FilePath $WrapFile -Encoding ASCII -Append -NoNewline
    Write-Success "Generated $($MockFunctions.Count) --wrap options"
} else {
    "# Empty mock wrap file - no mocks declared" | Out-File -FilePath $WrapFile -Encoding ASCII
    Write-Info "Created empty wrap file (no mocks to wrap)"
}

# Step 4: Generate CMake integration
Write-Info "Generating CMake integration: $CMakeFile"

$BaseNameUpper = $BaseName.ToUpper().Replace('-','_')
$WrapFileName = Split-Path -Leaf $WrapFile

$CMakeContent = @"
# Auto-generated mock configuration for $BaseName
# Generated by dap_mock_autowrap.ps1

# Linker wrapping options
set(${BaseNameUpper}_WRAP_FILE
    `${CMAKE_CURRENT_SOURCE_DIR}/$WrapFileName
)

# Read wrap options from file
file(READ `${${BaseNameUpper}_WRAP_FILE} ${BaseNameUpper}_WRAP_OPTIONS)
string(REPLACE "\n" ";" ${BaseNameUpper}_WRAP_LIST "`${${BaseNameUpper}_WRAP_OPTIONS}")

# Apply to test target
target_link_options($BaseName PRIVATE
    `${${BaseNameUpper}_WRAP_LIST}
)

# Wrapped functions (for documentation):
"@

if ($MockFunctions.Count -gt 0) {
    foreach ($func in $MockFunctions) {
        $CMakeContent += "`n#   - $func"
    }
} else {
    $CMakeContent += "`n#   (none - no mocks declared)"
}

$CMakeContent | Out-File -FilePath $CMakeFile -Encoding ASCII

Write-Success "Generated CMake integration"

# Step 5: Find missing wrappers and generate template
if ($MockFunctions.Count -eq 0) {
    Write-Info "No mocks declared - skipping template generation"
    $MissingFunctions = @()
} else {
    $MissingFunctions = $MockFunctions | Where-Object { $WrapperFunctions -notcontains $_ }
    
    if ($MissingFunctions.Count -eq 0) {
        Write-Success "All wrappers are defined, no template needed"
    } else {
        Write-Warning2 "Missing wrappers for $($MissingFunctions.Count) functions"
        Write-Info "Generating template: $TemplateFile"
        
        $TemplateContent = @"
// Auto-generated wrapper templates for $TestSource
// Copy these to your test file and fill in parameter types

#include "dap_mock_framework.h"
#include "dap_mock_linker_wrapper.h"

"@
        
        foreach ($func in $MissingFunctions) {
            $TemplateContent += @"

// TODO: Define wrapper for $func
// Example for int return:
// DAP_MOCK_WRAPPER_INT($func,
//     (type1 a_param1, type2 a_param2),
//     (a_param1, a_param2))
//
// Example for pointer return:
// DAP_MOCK_WRAPPER_PTR($func,
//     (type1 a_param1),
//     (a_param1))
//
// Example for void:
// DAP_MOCK_WRAPPER_VOID_FUNC($func,
//     (type1 a_param1),
//     (a_param1))

"@
        }
        
        $TemplateContent | Out-File -FilePath $TemplateFile -Encoding ASCII
        
        Write-Success "Template generated with $($MissingFunctions.Count) function stubs"
        foreach ($func in $MissingFunctions) {
            Write-Host "   ‚ö†Ô∏è  $func"
        }
    }
}

# Summary
Write-Header "‚úÖ Generation Complete!"

Write-Host ""
Write-Host "Generated files:"
Write-Host "  üìÑ $WrapFile"
Write-Host "  üìÑ $CMakeFile"
if ($MissingFunctions -and $MissingFunctions.Count -gt 0) {
    Write-Host "  üìÑ $TemplateFile"
}

Write-Host ""
Write-Host "To use in CMakeLists.txt:"
Write-Host "  include($(Split-Path -Leaf $CMakeFile))"
Write-Host ""
Write-Host "Or use CMake function:"
Write-Host "  dap_mock_wrap_from_file($BaseName $(Split-Path -Leaf $WrapFile))"

